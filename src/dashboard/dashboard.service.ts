import { Injectable } from '@nestjs/common';
import { PrismaService } from 'prisma/prisma.service';
import { decode } from 'src/constants/decode';
import {
  getCodeforcesContributionGraph,
  getGithubContributionGraph,
  getGithubUsername,
  getLeetcodeContributionGraph,
  pinnedRepos,
  getCFRatingGraph,
  getCFTagandProblemGraph,
  getGithubGraphsTogether,
  getLeetcodeGraphs,
} from 'src/constants/profile.data';
import {
  CodeforcesGraphsOutput,
  ContributionGraph,
  GithubGraphsOutput,
  LeetcodeGraphsOutput,
  User,
} from 'src/graphql.types';
import { BadRequestException } from '@nestjs/common';
import { HttpException, HttpStatus } from '@nestjs/common';

@Injectable()
export class DashboardService {
  constructor(private prisma: PrismaService) {}

  /**
   * It takes a userId and a token, decodes the token, finds the user, creates a contribution graph
   * object, fills it with data from Codeforces, Github and Leetcode, and returns the contribution graph
   * object
   * @param {string} userId - The userId of the user whose contribution graph is to be fetched.
   * @param {string} token - The token that was generated when the user logged in.
   * @returns A contribution graph object
   */
  async getContributionGraph(
    userId: string,
    token: string,
  ): Promise<ContributionGraph> {
    await decode(token, this.prisma);
    let user: User;
    try {
      user = await this.prisma.user.findUnique({
        where: { id: userId },
      });
    } catch (error) {
      throw new BadRequestException('Invalid userId');
    }
    const contributionGraph: ContributionGraph = {
      totalContributions: 0,
      contributions: [],
    };
    for (let i = 364; i >= 0; i--) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      contributionGraph.contributions.push({
        date: date.toISOString().split('T')[0],
        codeforcesContributions: 0,
        githubContributions: 0,
        leetcodeContributions: 0,
      });
    }
    await Promise.all([
      this.fillCodeforcesData(user, contributionGraph),
      this.fillGithubData(user, contributionGraph),
      this.fillLeetcodeData(user, contributionGraph),
    ]);
    return contributionGraph;
  }

  /**
   * It takes a userId and a token, decodes the token, finds the user, and then returns the pinned
   * repos from the user's github account
   * @param {string} userId - The userId of the user who's pinned repos we want to get
   * @param {string} token - The token that was generated when the user logged in.
   * @returns An array of pinned repos
   */
  async getPinnedRepos(userId: string, token: string) {
    await decode(token, this.prisma);
    let user: User;
    try {
      user = await this.prisma.user.findUnique({
        where: { id: userId },
      });
    } catch (error) {
      throw new BadRequestException('Invalid userId');
    }
    if (user.githubToken) {
      try {
        const githubUsername = await getGithubUsername(user.githubToken);
        return await pinnedRepos(githubUsername, user.githubToken);
      } catch (err) {
        throw new HttpException(
          'Github token is invalid',
          HttpStatus.BAD_REQUEST,
        );
      }
    }
    return [];
  }

  /**
   * It takes in a userId and a token, verifies the token, and then fetches the Codeforces username
   * from the database and uses it to fetch the Codeforces graphs
   * @param {string} userId - The userId of the user whose graphs are to be fetched.
   * @param {string} token - The token that is generated when the user logs in.
   * @returns the CodeforcesGraphsOutput object.
   */
  async codeforcesGraphs(
    userId: string,
    token: string,
  ): Promise<CodeforcesGraphsOutput | null> {
    await decode(token, this.prisma);
    let user: User;
    try {
      user = await this.prisma.user.findUnique({
        where: { id: userId },
      });
    } catch (error) {
      throw new BadRequestException('Invalid userId');
    }
    if (user.codeforcesUsername) {
      try {
        const [ratings, tagAndRatingGraph] = await Promise.all([
          getCFRatingGraph(user.codeforcesUsername),
          getCFTagandProblemGraph(user.codeforcesUsername),
        ]);
        return {
          ratingGraph: { ratings: ratings || [] },
          barGraph: { problemRatingGraph: tagAndRatingGraph.ratingArray || [] },
          donutGraph: { problemTagGraph: tagAndRatingGraph.tagArray || [] },
        };
      } catch (err) {
        throw new HttpException(
          'Codeforces username is invalid',
          HttpStatus.BAD_REQUEST,
        );
      }
    }
    return null;
  }

  /**
   * It takes in a userId and a token, decodes the token, finds the user in the database, and then uses
   * the user's github token to get their github graphs
   * @param {string} userId - The userId of the user who's github token we want to use
   * @param {string} token - The token that was generated by the login mutation.
   * @returns GithubGraphsOutput | null
   */
  async githubGraphs(
    userId: string,
    token: string,
  ): Promise<GithubGraphsOutput | null> {
    await decode(token, this.prisma);
    let user: User;
    try {
      user = await this.prisma.user.findUnique({
        where: { id: userId },
      });
    } catch (error) {
      throw new BadRequestException('Invalid userId');
    }
    if (user.githubToken) {
      try {
        const githubUsername = await getGithubUsername(user.githubToken);
        return await getGithubGraphsTogether(githubUsername, user.githubToken);
      } catch (err) {
        throw new HttpException(
          err?.message || 'Github token is invalid',
          HttpStatus.BAD_REQUEST,
        );
      }
    }
  }

  /**
   * It takes in a userId and a token, decodes the token, finds the user with the userId, and then
   * returns the leetcode graphs of the user if the user has a leetcode username
   * @param {string} userId - The userId of the user who's leetcode graphs we want to fetch
   * @param {string} token - The token that was generated when the user logged in.
   * @returns LeetcodeGraphsOutput
   */
  async leetcodeGraphs(
    userId: string,
    token: string,
  ): Promise<LeetcodeGraphsOutput> {
    await decode(token, this.prisma);
    let user: User;
    try {
      user = await this.prisma.user.findUnique({
        where: { id: userId },
      });
    } catch (error) {
      throw new BadRequestException('Invalid userId');
    }
    if (user.leetcodeUsername) {
      try {
        return await getLeetcodeGraphs(user.leetcodeUsername);
      } catch (err) {
        throw new HttpException(
          err?.message || 'Leetcode token is invalid',
          HttpStatus.BAD_REQUEST,
        );
      }
    }
  }

  /**
   * It takes a user object and a contribution graph object as parameters, and then it fills the
   * contribution graph object with the user's Codeforces data
   * @param {User} user - User - The user object that we are getting the contribution graph for.
   * @param {ContributionGraph} contributionGraph - This is the object that we will be returning to the user.
   */
  async fillCodeforcesData(user: User, contributionGraph: ContributionGraph) {
    if (user.codeforcesUsername) {
      try {
        const codeforcesData = await getCodeforcesContributionGraph(
          user.codeforcesUsername,
        );
        let totalCodeforcesContributions = 0;
        for (const submission of codeforcesData) {
          if (submission.verdict === 'OK') {
            const date = new Date(submission.creationTimeSeconds * 1000);
            const index = contributionGraph.contributions.findIndex(
              (contribution) =>
                contribution.date === date.toISOString().split('T')[0],
            );
            if (index !== -1) {
              contributionGraph.contributions[index].codeforcesContributions++;
              totalCodeforcesContributions++;
            }
          }
        }
        contributionGraph.totalCodeforcesContributions =
          totalCodeforcesContributions;
        contributionGraph.totalContributions += totalCodeforcesContributions;
      } catch (error) {
        throw new HttpException(
          'Codeforces username is invalid',
          HttpStatus.BAD_REQUEST,
        );
      }
    }
  }

  /**
   * It takes a user object and a contribution graph object, and if the user has a leetcode username,
   * it fetches the leetcode contribution graph and adds it to the contribution graph object
   * @param {User} user - User - The user object that we get from the database.
   * @param {ContributionGraph} contributionGraph - This is the object that we will be returning to the user.
   */
  async fillLeetcodeData(user: User, contributionGraph: ContributionGraph) {
    if (user.leetcodeUsername) {
      try {
        const leetcodeData = await getLeetcodeContributionGraph(
          user.leetcodeUsername,
        );
        let totalLeetcodeContributions = 0;
        for (const key in leetcodeData) {
          const date = new Date(parseInt(key, 10) * 1000);
          console.assert(!isNaN(date.getTime()));
          const check = date.toISOString().split('T')[0];
          const index = contributionGraph.contributions.findIndex(
            (contribution) => contribution.date === check,
          );
          if (index !== -1) {
            contributionGraph.contributions[index].leetcodeContributions =
              leetcodeData[key];
            totalLeetcodeContributions += leetcodeData[key];
          }
        }
        contributionGraph.totalLeetcodeContributions =
          totalLeetcodeContributions;
        contributionGraph.totalContributions += totalLeetcodeContributions;
      } catch (err) {
        throw new HttpException(
          'Leetcode username is invalid',
          HttpStatus.BAD_REQUEST,
        );
      }
    }
  }

  /**
   * It takes a user and a contribution graph as input, and if the user has a github token, it fetches
   * the user's github contribution data and adds it to the contribution graph
   * @param {User} user - User - The user object that is passed in from the controller.
   * @param {ContributionGraph} contributionGraph - This is the object that we will be returning to the
   * user. It contains the total contributions, total github contributions, and an array of
   * contributions.
   */
  async fillGithubData(user: User, contributionGraph: ContributionGraph) {
    if (user.githubToken) {
      try {
        const githubUsername = await getGithubUsername(user.githubToken);
        const githubContributionData = await getGithubContributionGraph(
          githubUsername,
          user.githubToken,
        );
        let totalGithubContributions = 0;
        for (let i = 0; i < githubContributionData.weeks.length; i++) {
          for (
            let j = 0;
            j < githubContributionData.weeks[i].contributionDays.length;
            j++
          ) {
            const date =
              githubContributionData.weeks[i].contributionDays[j].date;
            const index = contributionGraph.contributions.findIndex(
              (contribution) => contribution.date === date,
            );
            if (index !== -1) {
              contributionGraph.contributions[index].githubContributions =
                githubContributionData.weeks[i].contributionDays[
                  j
                ].contributionCount;
              totalGithubContributions +=
                githubContributionData.weeks[i].contributionDays[j]
                  .contributionCount;
            }
          }
        }
        contributionGraph.totalGithubContributions = totalGithubContributions;
        contributionGraph.totalContributions += totalGithubContributions;
      } catch (err) {
        throw new HttpException(
          'Github token is invalid',
          HttpStatus.BAD_REQUEST,
        );
      }
    }
  }
}
